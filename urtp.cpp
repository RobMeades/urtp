/* mbed Microcontroller Library
 * Copyright (c) 2017 u-blox
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "mbed.h"
#include "urtp.h"

#ifdef ENABLE_RAMLOG
#include "ioc_log.h"
#else
#define LOG(x, y) 
#endif

/**********************************************************************
 * STATIC VARIABLES
 **********************************************************************/

/** This variable gives the byte offset at which to grab the LSB,
 * middle byte and MSB for each orientation.
 */
static const int byteSelect[4][3] = {{3, 0, 1},
                                     {5, 2, 3},
                                     {7, 4, 5},
                                     {1, 6, 7}};

/** This variable gives the byte offset of all the bytes that should
 * be 0xFF for each orientation.
 */
static const int byteFf[4][5] = {{2, 4, 5, 6, 7},
                                 {0, 1, 4, 6, 7},
                                 {0, 1, 2, 3, 6},
                                 {0, 2, 3, 4, 5}};

#ifdef ENABLE_STREAM_FIXED_TONE
/** Diagnostics: a 400 Hz sine wave as a little-endian 24 bit signed PCM stream sampled at 16 kHz, generated by Audacity and
 * then sign extended to 32 bits per sample.
 */
static const int pcm400HzSigned24Bit[] = {(int) 0x00000000L, (int) 0x001004d5L, (int) 0x001fa4b2L, (int) 0x002e7d16L, (int) 0x003c3070L, (int) 0x00486861L, (int) 0x0052d7e5L, (int) 0x005b3d33L, (int) 0x00616360L, (int) 0x006523a8L,
                                          (int) 0x00666666L, (int) 0x006523a8L, (int) 0x00616360L, (int) 0x005b3d33L, (int) 0x0052d7e5L, (int) 0x00486861L, (int) 0x003c3070L, (int) 0x002e7d16L, (int) 0x001fa4b2L, (int) 0x001004d5L,
                                          (int) 0x00000000L, (int) 0xffeffb2aL, (int) 0xffe05b4eL, (int) 0xffd182e9L, (int) 0xffc3cf90L, (int) 0xffb7979eL, (int) 0xffad281bL, (int) 0xffa4c2ccL, (int) 0xff9e9ca0L, (int) 0xff9adc57L,
                                          (int) 0xff999999L, (int) 0xff9acd57L, (int) 0xff9e9ca0L, (int) 0xffa4c2ccL, (int) 0xffad281bL, (int) 0xffb7979eL, (int) 0xffc3cf90L, (int) 0xffd182e9L, (int) 0xffe05beeL, (int) 0xffeffb2aL};

/** Diagnostics: index into pcm400HzSigned24Bit.
 */
static unsigned int toneIndex = 0;
#endif

/**********************************************************************
 * PRIVATE METHODS
 **********************************************************************/

// Take an audio sample and from it produce a signed
// output that uses the maximum number of bits
// in a 32 bit word.
int Urtp::processAudio(int monoSample)
{
    int unusedBits = 0;
    int absSample = monoSample;

    //LOG(EVENT_STREAM_MONO_SAMPLE_DATA, monoSample);

    // First, determine the number of unused bits
    // (avoiding testing the top bit since that is
    // never unused)
    if (absSample < 0) {
        absSample = -absSample;
    }

    for (int x = 30; x >= 0; x--) {
        if (absSample & (1 << x)) {
            break;
        } else {
            unusedBits++;
        }
    }

    //LOG(EVENT_MONO_SAMPLE_UNUSED_BITS, unusedBits);

    if (_audioShiftFixed >= 0) {
        monoSample <<= _audioShiftFixed;
    } else {
        monoSample <<= _audioShift;
    }

    // Add the new unused bits count to the buffer and
    // update the minimum
    if (unusedBits < _audioUnusedBitsMin) {
        _audioUnusedBitsMin = unusedBits;
    }
    _audioShiftSampleCount++;
    // If we've had a block's worth of data, work out how muhc gain we may be
    // able to apply for the next period
    if (_audioShiftSampleCount >= SAMPLING_FREQUENCY / (1000 / BLOCK_DURATION_MS)) {
        _audioShiftSampleCount = 0;
        //LOG(EVENT_MONO_SAMPLE_UNUSED_BITS_MIN, _audioUnusedBitsMin);
        if (_audioShift > _audioUnusedBitsMin) {
            _audioShift = _audioUnusedBitsMin;
        }
        if ((_audioUnusedBitsMin - _audioShift > AUDIO_DESIRED_UNUSED_BITS) && (_audioShift < AUDIO_MAX_SHIFT_BITS)) {
            _audioShift++;
            LOG(EVENT_MONO_SAMPLE_AUDIO_SHIFT, _audioShift);
        } else if ((_audioUnusedBitsMin - _audioShift < AUDIO_DESIRED_UNUSED_BITS) && (_audioShift > 0)) {
            _audioShift--;
            LOG(EVENT_MONO_SAMPLE_AUDIO_SHIFT, _audioShift);
        }

        // Increment the minimum number of unused bits in the period
        // to let the number "relax"
        _audioUnusedBitsMin++;
    }

    //LOG(EVENT_STREAM_MONO_SAMPLE_PROCESSED_DATA, monoSample);

    return monoSample;
}

// Take a stereo sample in our usual form
// and return an int containing a sample
// that will fit within MONO_INPUT_SAMPLE_SIZE
// but sign extended so that it can be
// treated as an int for maths purposes.
inline int Urtp::getMonoSample(const uint32_t *stereoSample)
{
    const char * pByte = (const char *) stereoSample;
    unsigned int retValue = 0;

    if (_rawSampleRotation >= 0) {
        // LSB
        retValue = (unsigned int) *(pByte + byteSelect[_rawSampleRotation][0]);
        // Middle byte
        retValue += ((unsigned int) *(pByte + byteSelect[_rawSampleRotation][1])) << 8;
        // MSB
        retValue += ((unsigned int) *(pByte + byteSelect[_rawSampleRotation][2])) << 16;
        // Sign extend
        if (retValue & 0x800000) {
            retValue |= 0xFF000000;
        }
    }

#ifdef ENABLE_STREAM_FIXED_TONE
    retValue = pcm400HzSigned24Bit[toneIndex];
    toneIndex++;
    if (toneIndex >= sizeof (pcm400HzSigned24Bit) / sizeof (pcm400HzSigned24Bit[0])) {
        toneIndex = 0;
    }
#endif

    return (int) retValue;
}

// Encode UNICAM_COMPRESSED_x_BIT.
int Urtp::codeUnicam(const uint32_t *rawAudio, char *dest)
{
    int monoSample;
    int absSample;
    int maxSample = 0;
    int numBytes = 0;
    int numBlocks = 0;
    unsigned int i = 0;
    int usedBits;
    int shiftValue32Bit;
    int shiftValueCoded = 0;
    bool isEvenBlock = false;
#if UNICAM_CODED_SAMPLE_SIZE_BITS != 8
    int compressedSampleBitShift = 0;
    int compressedSample;
#endif
    char *pDestOriginal = dest;

    for (const uint32_t *stereoSample = rawAudio; stereoSample < rawAudio + (SAMPLES_PER_BLOCK * 2); stereoSample += 2) {

        //LOG(EVENT_RAW_AUDIO_DATA_0, *stereoSample);
        //LOG(EVENT_RAW_AUDIO_DATA_1, *(stereoSample + 1));

        monoSample = getMonoSample(stereoSample);
        monoSample = processAudio(monoSample);
        // Put the samples into the unicam buffer and track the max abs value
        absSample = monoSample;
        if (absSample < 0) {
            absSample = -absSample;
        }
        if (absSample > maxSample) {
            maxSample = absSample;
        }
        _unicamBuffer[i] = monoSample;
        i++;
        if (i >= sizeof (_unicamBuffer) / sizeof (_unicamBuffer[0])) {
            i = 0;
            shiftValue32Bit = 0;
            usedBits = 32;

            //LOG(EVENT_UNICAM_MAX_ABS_VALUE, maxSample);

            // Once we have a buffer full, work out the shift value
            // to just fit the maximum value into 8 bits.  First
            // find the number of bits used (avoid testing the top
            // bit since that is always used)
            for (int x = 30; x >= 0; x--) {
                if ((maxSample & (1 << x)) != 0) {
                    break;
                } else {
                    usedBits--;
                }
            }

            //LOG(EVENT_UNICAM_MAX_VALUE_USED_BITS, usedBits);

            maxSample = 0;
            if (usedBits >= UNICAM_CODED_SAMPLE_SIZE_BITS) {
                shiftValue32Bit = usedBits - UNICAM_CODED_SAMPLE_SIZE_BITS;
            }

            //LOG(EVENT_UNICAM_SHIFT_VALUE, shiftValue32Bit);

            // If we're on an odd block number, write the shift value into the upper
            // nibble of the preceding byte of the output.
            //
            // shiftValue32Bit shifts a 32 bit number (which we know will be a
            // 16 bit number shifted towards the left) into an 8 bit number.
            // The shift value that we code into the output stream should be
            // the number required to return the 8 bit number into a 16 bit
            // number.
            if (shiftValue32Bit >= 16) {
                shiftValueCoded = shiftValue32Bit - 16;
            }

            //LOG(EVENT_UNICAM_CODED_SHIFT_VALUE, shiftValueCoded);
            isEvenBlock = false;
            if ((numBlocks & 1) == 0) {
                isEvenBlock = true;
            }
            if (!isEvenBlock) {
                *dest = (*dest & 0xF0) | shiftValueCoded;
                //LOG(EVENT_UNICAM_CODED_SHIFTS_BYTE, *dest);
                dest++;
            }

            // Write into the output all the values in the buffer shifted down by this amount
            for (unsigned int x = 0; x < sizeof (_unicamBuffer) / sizeof (_unicamBuffer[0]); x++) {

                //LOG(EVENT_UNICAM_SAMPLE, _unicamBuffer[x]);

#if UNICAM_CODED_SAMPLE_SIZE_BITS != 8

                compressedSample = _unicamBuffer[x];
                // With 10-bit UNICAM, first shift the sample into position
                compressedSample >>= shiftValue32Bit;

                //LOG(EVENT_UNICAM_COMPRESSED_SAMPLE, compressedSample);
                // compressedSample now contains the 10 bit sample as follows:
                // xxxxxxxx xxxxxxxx xxxxxx98 76543210

                // Write the first portion
                // Note: unsigned to avoid sign extension in this case
                *dest |= (*dest & ~((unsigned char) 0xFF >> compressedSampleBitShift)) |
                          ((unsigned int) compressedSample >> (compressedSampleBitShift + UNICAM_CODED_SAMPLE_SIZE_BITS - 8));

                //LOG(EVENT_UNICAM_10_BIT_CODED_SAMPLE, *dest);
                dest++;

                // Shift the sample down again for the remaining bits
                // Then write the remaining bits into the next byte
                *dest |= (*dest & ((unsigned char) 0xFF >> (compressedSampleBitShift + UNICAM_CODED_SAMPLE_SIZE_BITS - 8))) |
                           (compressedSample << (8 - (compressedSampleBitShift + UNICAM_CODED_SAMPLE_SIZE_BITS - 8)));

                // Move the shift value on
                compressedSampleBitShift += UNICAM_CODED_SAMPLE_SIZE_BITS - 8;
                if (compressedSampleBitShift >= 8) {
                    compressedSampleBitShift = 0;
                }
                // Move the destination pointer on if the shift has wrapped
                if (compressedSampleBitShift == 0) {
                    //LOG(EVENT_UNICAM_10_BIT_CODED_SAMPLE, *dest);
                    dest++;
                }
#else
                // With 8-bit unicam, it's nice and simple
                *dest = _unicamBuffer[x] >> shiftValue32Bit;
                //LOG(EVENT_UNICAM_COMPRESSED_SAMPLE, *dest);
                dest++;
#endif
            }

            // If we're on an even block number...
            if (isEvenBlock) {
                *dest = (*dest & 0x0F) | (shiftValueCoded << 4);
            }

            numBlocks++;
        }
    }

    numBytes = dest - pDestOriginal;
    if (isEvenBlock) {
        numBytes++;
    }

    //LOG(EVENT_UNICAM_BLOCKS_CODED, numBlocks);
    //LOG(EVENT_UNICAM_BYTES_CODED, numBytes);

    return numBytes;
}

// Encode PCM_SIGNED_16_BIT.
int Urtp::codePcm(const uint32_t *rawAudio, char *dest)
{
    int monoSample;
    int numSamples = 0;

    for (const uint32_t *stereoSample = rawAudio; stereoSample < rawAudio + (SAMPLES_PER_BLOCK * 2); stereoSample += 2) {

        //LOG(EVENT_RAW_AUDIO_DATA_0, *stereoSample);
        //LOG(EVENT_RAW_AUDIO_DATA_1, *(stereoSample + 1));

        monoSample = getMonoSample(stereoSample);
        numSamples++;
        monoSample = processAudio(monoSample);

        *dest = (char) (monoSample >> 24);
        dest++;
#if URTP_SAMPLE_SIZE > 1
        *dest = (char) (monoSample >> 16);
        dest++;
#endif
#if URTP_SAMPLE_SIZE > 2
        *dest = (char) (monoSample >> 8);
        dest++;
#endif
#if URTP_SAMPLE_SIZE > 3
        *dest = (char) monoSample;
        dest++;
#endif
    }

    //LOG(EVENT_DATAGRAM_NUM_SAMPLES, numSamples);

    return numSamples * URTP_SAMPLE_SIZE;
}

// Fill a datagram with the audio from one block.
void Urtp::fillMonoDatagramFromBlock(const uint32_t *rawAudio)
{
    Container * container = getContainerForWriting();
    char * datagram = (char *) container->contents;
    uint64_t timestamp = _timeDatagram.read_high_resolution_us();
    int numBytesAudio = 0;

    // Copy in the body ASAP in case we're called from
    // DMA, which might catch up with us
#ifndef DISABLE_UNICAM
    numBytesAudio = codeUnicam (rawAudio, datagram + URTP_HEADER_SIZE);
#else
    numBytesAudio = codePcm (rawAudio, datagram + URTP_HEADER_SIZE);
#endif
    // Fill in the header
    *datagram = SYNC_BYTE;
    datagram++;
#ifndef DISABLE_UNICAM
# if UNICAM_CODED_SAMPLE_SIZE_BITS == 8
    *datagram = UNICAM_COMPRESSED_8_BIT;
# else
    *datagram = UNICAM_COMPRESSED_10_BIT;
# endif
#else
    *datagram = PCM_SIGNED_16_BIT;
#endif
    datagram++;
    *datagram = (char) (_sequenceNumber >> 8);
    datagram++;
    *datagram = (char) _sequenceNumber;
    datagram++;
    _sequenceNumber++;
    *datagram = (char) (timestamp >> 56);
    datagram++;
    *datagram = (char) (timestamp >> 48);
    datagram++;
    *datagram = (char) (timestamp >> 40);
    datagram++;
    *datagram = (char) (timestamp >> 32);
    datagram++;
    *datagram = (char) (timestamp >> 24);
    datagram++;
    *datagram = (char) (timestamp >> 16);
    datagram++;
    *datagram = (char) (timestamp >> 8);
    datagram++;
    *datagram = (char) timestamp;
    datagram++;
    *datagram = (char) (numBytesAudio >> 8);
    datagram++;
    *datagram = (char) numBytesAudio;
    datagram++;

    //LOG(EVENT_DATAGRAM_SIZE, datagram - (char *)container->contents + numBytesAudio);

    // The container is now ready to read
    setContainerAsReadyToRead(container);
}

// Establish where the wanted bits are in the raw audio stream.
int Urtp::getRotation(const uint32_t *stereoSample)
{
    const char * pByte;
    bool foundIt;
    int rotationVote[4] = {0};
    unsigned int x;
    unsigned int y;
    int rotationResult = -1;

    for (x = 0; x < sizeof(_rotationBuffer) / sizeof(_rotationBuffer[0]); x++) {
        pByte = (const char *) stereoSample;
        _rotationBuffer[x] = -1;
        foundIt = false;

        //LOG(EVENT_RAW_AUDIO_DATA_0, *stereoSample);
        //LOG(EVENT_RAW_AUDIO_DATA_1, *(stereoSample + 1));

        // Find the pattern of 0xFF bytes
        for (y = 0; (y < sizeof(byteFf) / sizeof(byteFf[0])) && !foundIt; y++) {
            foundIt = true;
            for (unsigned int z = 0; (z < sizeof(byteFf[0]) / sizeof(byteFf[0][0])) && foundIt; z++) {
                if (*(pByte + byteFf[y][z]) != 0xFF) {
                    foundIt = false;
                }
            }
            if (foundIt) {
                // If we have found a pattern of 0xFF bytes that match, it could be a fluke, so
                // check if the LSB of the used bytes is not also xFF (the upper bytes could well
                // be 0xFF if the number is a small negative number)
                if (*(pByte + byteSelect[y][0]) == 0xFF) {
                    foundIt = false;
                }
            }
        }

        if (foundIt) {
            _rotationBuffer[x] = y - 1;
            //LOG(EVENT_RAW_AUDIO_POSSIBLE_ROTATION, _rotationBuffer[x]);
        }

        stereoSample += 2;
    }

    // Having been through the entire block, work out how many votes
    // we got for each rotation value
    for (x = 0; x < sizeof(_rotationBuffer) / sizeof(_rotationBuffer[0]); x++) {
        if (_rotationBuffer[x] >= 0) {
            rotationVote[_rotationBuffer[x]] += 1;
        }
    }

    // For debug
    for (x = 0; x < sizeof(rotationVote) / sizeof(rotationVote[0]); x++) {
        LOG(EVENT_RAW_AUDIO_ROTATION_VOTE, rotationVote[x]);
    }

    // Having counted the votes, do we have an outright winner?
    foundIt = false;
    for (x = 0; (x < sizeof(rotationVote) / sizeof(rotationVote[0])) && !foundIt; x++) {
        foundIt = true;
        for (y = 0; y < sizeof(rotationVote) / sizeof(rotationVote[0]) - 1; y++) {
            if (rotationVote[x] < rotationVote[(x + y + 1) % (sizeof(rotationVote) / sizeof(rotationVote[0]))] + ROTATION_VOTING_MARGIN) {
                foundIt = false;
            }
        }
    }

    if (foundIt) {
        rotationResult = x - 1;
        LOG(EVENT_RAW_AUDIO_DATA_ROTATION, rotationResult);
    } else {
        LOG(EVENT_RAW_AUDIO_DATA_ROTATION_NOT_FOUND, rotationResult);
    }

    return rotationResult;
}

// Test that right shift is an arithmetic operation
bool Urtp::unicamTest()
{
    int negative = -1;
    return (negative >> 1) < 0;
}

// Get the next container for writing.
inline Urtp::Container * Urtp::getContainerForWriting()
{
    Container * container = _containerNextForWriting;

    // In normal circumstances one would hope that the next container
    // for writing is empty.  However, it may be that the read
    // routine is running behind, in which case it could be in state
    // READY_TO_READ or, worse, state READING.  If it is in state
    // READY_TO_READ, then it can simply be overwritten with new data,
    // but if it is in state READING we must leave it alone and move
    // on or we will could corrupt the callers work.  There should
    // only ever be one container in state READING, so the for() loop
    // isn't strictly necessary, it is simply there to be safe.
    for (unsigned int x = 0; (container->state == CONTAINER_STATE_READING) &&
                             (x < sizeof (_container) / sizeof (_container[0])); x++) {
        _containerNextForWriting = container->next;
    }

    // Move the write pointer on
    _containerNextForWriting = container->next;

    if (container->state == CONTAINER_STATE_EMPTY) {
        _numDatagramsFree--;
        //LOG(EVENT_NUM_DATAGRAMS_FREE, _numDatagramsFree);
        if (_numDatagramsFree < _minNumDatagramsFree) {
            _minNumDatagramsFree = _numDatagramsFree;
        }
        if (_numDatagramOverflows > 0) {
            LOG(EVENT_DATAGRAM_NUM_OVERFLOWS, _numDatagramOverflows);
            _numDatagramOverflows = 0;
            if (_datagramOverflowStopCb) {
                _datagramOverflowStopCb(_numDatagramOverflows);
            }
        }
    } else {
        // If the container we're about to use is not empty, we're overwriting
        // old data.  To avoid the read pointer wrapping the write pointer,
        // nudge the read pointer on by one
        _containerNextForReading = _containerNextForReading->next;
        if (_numDatagramOverflows == 0) {
            LOG(EVENT_DATAGRAM_OVERFLOW_BEGINS, (int) container);
            if (_datagramOverflowStartCb) {
                _datagramOverflowStartCb();
            }
        }
        _numDatagramOverflows++;
    }
    container->state = CONTAINER_STATE_WRITING;
    //LOG(EVENT_CONTAINER_STATE_WRITING, (int) container);

    return container;
}

// Set the given container as ready to read.
// Must have been writing to this container for it to be now ready to read.
inline void Urtp::setContainerAsReadyToRead(Urtp::Container * container)
{
    MBED_ASSERT(container->state == CONTAINER_STATE_WRITING);
    container->state = CONTAINER_STATE_READY_TO_READ;
    //LOG(EVENT_CONTAINER_STATE_READY_TO_READ, (int) container);

    // Tell the callback that the contents are ready for reading
    if (_datagramReadyCb) {
        _datagramReadyCb((const char *) container->contents);
    }
}

// Get the next container for reading.
// Only if the next container for reading is ready to read, or
// is already being read, can it be returned, otherwise
// NULL is returned
inline Urtp::Container * Urtp::getContainerForReading()
{
    Container * container = _containerNextForReading;

    if ((container->state == CONTAINER_STATE_READY_TO_READ) ||
        (container->state == CONTAINER_STATE_READING)) {
        container->state = CONTAINER_STATE_READING;
        //LOG(EVENT_CONTAINER_STATE_READING, (int) container);
    } else {
        container = NULL;
    }

    return container;
}

// Set the given container as read.
// Must have been reading this container to mark it as read.  Once
// this container is marked as read the read pointer can be moved on
// and the container freed up.
inline void Urtp::setContainerAsRead(Urtp::Container * container)
{
    MBED_ASSERT(container->state == CONTAINER_STATE_READING);
    _containerNextForReading = container->next;
    //LOG(EVENT_CONTAINER_STATE_READ, (int) container);
    setContainerAsEmpty(container);
}

// Set the given container as empty.
inline void Urtp::setContainerAsEmpty(Urtp::Container * container)
{
    container->state = CONTAINER_STATE_EMPTY;
    _numDatagramsFree++;
    //LOG(EVENT_CONTAINER_STATE_EMPTY, (int) container);
    //LOG(EVENT_NUM_DATAGRAMS_FREE, _numDatagramsFree);
}

/**********************************************************************
 * PUBLIC METHODS
 **********************************************************************/

// Constructor.
Urtp::Urtp(Callback<void(const char *)> datagramReadyCb,
           Callback<void()> datagramOverflowStartCb,
           Callback<void(int)> datagramOverflowStopCb)
{
    _datagramReadyCb = datagramReadyCb;
    _datagramOverflowStartCb = datagramOverflowStartCb;
    _datagramOverflowStopCb = datagramOverflowStopCb;
    _datagramMemory = NULL;
    _containerNextForWriting = _container;
    _containerNextForReading = _container;
    _rawSampleRotation = -1;
    _audioShiftSampleCount = 0;
    _audioUnusedBitsMin = 0x7FFFFFFF;
    _audioShift = 0;
    _audioShiftFixed = -1;
    _sequenceNumber = 0;
    _numDatagramOverflows = 0;
    _numDatagramsFree = 0;
    _minNumDatagramsFree = 0;
}

// Destructor
Urtp::~Urtp()
{
}

// Initialise ourselves.
bool Urtp::init(void *datagramStorage, int audioShiftFixed)
{
    bool success = false;
    int x = 0;
    Container *tmp = NULL;

    _audioShiftFixed = audioShiftFixed;

#ifdef DISABLE_UNICAM
    {
#else
    if (unicamTest()) {
#endif
        _datagramMemory = (char *) datagramStorage;

        if (_datagramMemory != NULL) {
            // Initialise the linked list
            _numDatagramsFree = 0;
            // This looks peculiar but it is deliberate: container is moved
            // on in the body of the loop in order to deal with the next pointer,
            // x is advanced as the for loop variable
            for (Container *container = _container;
                 container < _container + sizeof (_container) / sizeof (_container[0]);
                 x += URTP_DATAGRAM_SIZE) {
                container->contents = (void *) (_datagramMemory + x);
                container->state = CONTAINER_STATE_EMPTY;
                _numDatagramsFree++;
                container->next = NULL;
                tmp = container;
                container++;
                tmp->next = container;
            }
            // Handle the final next, making the list circular
            tmp->next = _container;
            _minNumDatagramsFree = _numDatagramsFree;

            LOG(EVENT_NUM_DATAGRAMS_FREE, _numDatagramsFree);
        }

        // Reset the datagram timestamp
        _timeDatagram.reset();
        _timeDatagram.start();

        // Force a rotation check
        _rawSampleRotation = -1;

#ifdef ENABLE_STREAM_FIXED_TONE
        toneIndex = 0;
#endif

        success = true;
    }

    return success;
}

// URTP encode an audio block.
void Urtp::codeAudioBlock (const uint32_t *rawAudio)
{
    if (_rawSampleRotation < 0) {
        _rawSampleRotation = getRotation(rawAudio);
    } else {
        fillMonoDatagramFromBlock(rawAudio);
    }
}

// Return a pointer to the next filled URTP datagram.
const char * Urtp::getUrtpDatagram()
{
    const char * contents = NULL;
    Container * container = getContainerForReading();

    if (container != NULL) {
        contents = (const char *) container->contents;
    }

    return contents;
}

// Free a URTP datagram that has been read.
void Urtp::setUrtpDatagramAsRead(const char *datagram)
{
    bool freedIt = false;
    Container *container = _containerNextForReading;

    // This looks pretty inefficient but the datagram being freed will
    // always be _containerNextForReading, so it should be found immediately
    for (unsigned int x = 0; (x < sizeof (_container) / sizeof (_container[0])) && !freedIt; x++) {
        if ((const char *) container->contents == datagram) {
            setContainerAsRead(container);
            freedIt = true;
        }
    }
}

// The number of datagrams available
int Urtp::getUrtpDatagramsAvailable()
{
    return sizeof (_container) / sizeof (_container[0]) - _numDatagramsFree;
}

// The number of datagrams free
int Urtp::getUrtpDatagramsFree()
{
    return _numDatagramsFree;
}

// The minimum number of datagrams free
int Urtp::getUrtpDatagramsFreeMin()
{
    return _minNumDatagramsFree;
}

// End of file
